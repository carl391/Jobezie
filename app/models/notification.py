"""
Notification Model

Handles user notifications for follow-up reminders, usage warnings,
and system announcements.
"""

import uuid
from datetime import datetime
from enum import Enum

from app.extensions import db
from app.models.user import GUID, JSONType


class NotificationType(str, Enum):
    """Type of notification."""

    FOLLOW_UP_REMINDER = "follow_up_reminder"
    USAGE_WARNING = "usage_warning"
    TIER_LIMIT = "tier_limit"
    SYSTEM = "system"
    ACHIEVEMENT = "achievement"
    MARKET_ALERT = "market_alert"


class Notification(db.Model):
    """
    Notification model for user alerts and reminders.

    Stores notifications generated by the system for follow-up reminders,
    usage warnings, achievements, and market alerts.
    """

    __tablename__ = "notifications"

    id = db.Column(GUID(), primary_key=True, default=uuid.uuid4)
    user_id = db.Column(
        GUID(),
        db.ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    title = db.Column(db.String(255), nullable=False)
    body = db.Column(db.Text, nullable=True)
    notification_type = db.Column(
        db.String(50),
        nullable=False,
        default=NotificationType.SYSTEM.value,
    )
    is_read = db.Column(db.Boolean, default=False, nullable=False)
    action_url = db.Column(db.String(500), nullable=True)
    extra_data = db.Column("metadata", JSONType, default=dict)
    created_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)

    # Relationships
    user = db.relationship("User", backref=db.backref("notifications", lazy="dynamic"))

    def to_dict(self):
        """Serialize notification to dictionary."""
        return {
            "id": str(self.id),
            "user_id": str(self.user_id),
            "title": self.title,
            "body": self.body,
            "type": self.notification_type,
            "is_read": self.is_read,
            "action_url": self.action_url,
            "metadata": self.extra_data or {},
            "created_at": self.created_at.isoformat() if self.created_at else None,
        }

    def __repr__(self):
        return f"<Notification {self.id} type={self.notification_type} read={self.is_read}>"
